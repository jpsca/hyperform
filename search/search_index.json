{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Proper Form Documentation # Proper Form is a python library for modern form input handling and validation. It tries very hard not to be terrible like all the others: The main problem I used to have with it was the markup. I wanted Bootstrap classes . I wanted complex layouts like multiple columns. \u2014 Random Redditor How Proper Form is different # Your form can have nested subforms, to create or update several objects, in the same page, at once. No need for modals or separated pages. Any field can accept multiple values; as a list or as a comma-separated text. A field isn\u2019t tied to a specific HTML tag, so can be presentend in multiple ways. Even the same form can be used in different contexts and have different widgets and styles on each. Incredible easy to integrate with any ORM (object-relational mapper). Built-in adaptators for SQLAlchemy and Pony. Commonly used built-in validators, but you can write simple functions to use as custom ones. All error messages are editable. We are not robots, the tone of the messages must be able to change or to be translated. Just show me how it looks # from proper_form import Form , Email , Text class CommentForm ( Form ): email = Email ( required = True , check_dns = True ) message = Text ( LongerThan ( 5 , \"Please write a longer message\" ), required = True ) def comment (): form = CommentForm ( request . POST ) if request . method == \"POST\" and form . validate (): data = form . save () ... return render_template ( \"comment.html\" , form = form ) Installation # # Create a virtual environment python - m venv . venv # Activate said environment source . venv / bin / activate # Install the library python - m pip install proper_form","title":"Welcome"},{"location":"#proper-form-documentation","text":"Proper Form is a python library for modern form input handling and validation. It tries very hard not to be terrible like all the others: The main problem I used to have with it was the markup. I wanted Bootstrap classes . I wanted complex layouts like multiple columns. \u2014 Random Redditor","title":"Proper Form Documentation"},{"location":"#how-proper-form-is-different","text":"Your form can have nested subforms, to create or update several objects, in the same page, at once. No need for modals or separated pages. Any field can accept multiple values; as a list or as a comma-separated text. A field isn\u2019t tied to a specific HTML tag, so can be presentend in multiple ways. Even the same form can be used in different contexts and have different widgets and styles on each. Incredible easy to integrate with any ORM (object-relational mapper). Built-in adaptators for SQLAlchemy and Pony. Commonly used built-in validators, but you can write simple functions to use as custom ones. All error messages are editable. We are not robots, the tone of the messages must be able to change or to be translated.","title":"How Proper Form is different"},{"location":"#just-show-me-how-it-looks","text":"from proper_form import Form , Email , Text class CommentForm ( Form ): email = Email ( required = True , check_dns = True ) message = Text ( LongerThan ( 5 , \"Please write a longer message\" ), required = True ) def comment (): form = CommentForm ( request . POST ) if request . method == \"POST\" and form . validate (): data = form . save () ... return render_template ( \"comment.html\" , form = form )","title":"Just show me how it looks"},{"location":"#installation","text":"# Create a virtual environment python - m venv . venv # Activate said environment source . venv / bin / activate # Install the library python - m pip install proper_form","title":"Installation"},{"location":"crash/","text":"Crash course # Key Concepts # Form s are the core container of Proper Form, they are classes that group fields and/or formsets and, sometimes, connect them to models. Fields do most of the heavy lifting. Each field represents a data type and the field handles coercing form the input string to that datatype. They can also run validations on the values. Every field can be rendered as any form widget (inputs, selects, checboxes), even if a particular widget don\u2019t make sense for the data type. In order to specify validation rules, fields contain a list of validator functions. Formsets are lists of subforms. You can control if adding new forms or deleting old ones is allowed. Diving into it # This is an example of a simple form connected to a Model: # forms.py from proper_form import SQLAForm , Text , LongerThan from .models import db , Message class BaseForm ( SQLAForm ): _session = db . session class MessageForm ( BaseForm ): _model = Message your_name = Text ( required = True ) message = Text ( LongerThan ( 5 , \"Please write a longer message\" ), required = True ) Our form has two text fields, both required. The second one has a validator to ensure that the value is longer than five characters. You can have several validators on each field. There are three steps involved in using a form. [1] First , we need to show the form to the user. Let\u2019s see it with an example in Flask. First, in your controller, we create a form instance using the input data and the existing object (that could be None , if it doesn\u2019t exist yet): Controller from flask import request , render_template from .app import app from .forms import MessageForm from .models import db , Message @app.route ( \"/messages/new/\" , methods = [ \"GET\" , \"POST\" ]) @app.route ( \"/messages/<int:msg_id>/edit/\" , methods = [ \"GET\" , \"POST\" ]) def edit ( msg_id = None ): # Load the message if exists message = None if msg_id : message = db . query ( Message ) . filter_by ( id = msg_id ) . first () form = MessageForm ( request . form , message ) # TODO return render_template ( \"message_edit.html.jinja2\" , form = form , ) Template {% extends \"layout.html\" %} {% block title %} Edit message {% endblock %} {% block content %} < form method = \"post\" action = \"\" > < div class = \"form-group\" > {{ form.your_name.as_input ( label = \"Name:\" ) }} {{ form.your_name.render_error () }} </ div > < div class = \"form-group\" > {{ form.message.as_textarea ( label = \"Message:\" ) }} {{ form.message.render_error () }} </ div > < button type = \"submit\" class = \"btn btn-primary\" > Save </ button > </ form > {% endblock %} [2] Second , we process the input data the user send using the form: from flask import request , render_template , redirect , url_for , flash from .app import app from .forms import MessageForm from .models import db , Message @app.route ( \"/messages/new/\" , methods = [ \"GET\" , \"POST\" ]) @app.route ( \"/messages/<int:msg_id>/edit/\" , methods = [ \"GET\" , \"POST\" ]) def edit ( msg_id = None ): if msg_id : message = db . query ( Message ) . filter_by ( id = msg_id ) . first () else : message = None form = MessageForm ( request . form , message ) # [2] if request . method == 'POST' and form . validate (): # [3] form . save () flash ( \"Message saved.\" , 'success' ) return redirect ( url_for ( \"messages\" )) return render_template ( \"message_edit.html.jinja2\" , form = form , ) Note that we have it so validate() is only called if there is POST data. The reason we gate the validation check this way is that, when there is no POST data (like in step [1]), we don\u2019t want to cause validation errors. If the form was submitted and has errors, it\u2019ll be shown again to the user, only this time with error messages. [3] Finally , if the form is valid, we do something with the data. In this example, form.save() creates/update a Message object in the database. After we finish processing the form, we do a redirect to another page.","title":"Crash course"},{"location":"crash/#crash-course","text":"","title":"Crash course"},{"location":"crash/#key-concepts","text":"Form s are the core container of Proper Form, they are classes that group fields and/or formsets and, sometimes, connect them to models. Fields do most of the heavy lifting. Each field represents a data type and the field handles coercing form the input string to that datatype. They can also run validations on the values. Every field can be rendered as any form widget (inputs, selects, checboxes), even if a particular widget don\u2019t make sense for the data type. In order to specify validation rules, fields contain a list of validator functions. Formsets are lists of subforms. You can control if adding new forms or deleting old ones is allowed.","title":"Key Concepts"},{"location":"crash/#diving-into-it","text":"This is an example of a simple form connected to a Model: # forms.py from proper_form import SQLAForm , Text , LongerThan from .models import db , Message class BaseForm ( SQLAForm ): _session = db . session class MessageForm ( BaseForm ): _model = Message your_name = Text ( required = True ) message = Text ( LongerThan ( 5 , \"Please write a longer message\" ), required = True ) Our form has two text fields, both required. The second one has a validator to ensure that the value is longer than five characters. You can have several validators on each field. There are three steps involved in using a form. [1] First , we need to show the form to the user. Let\u2019s see it with an example in Flask. First, in your controller, we create a form instance using the input data and the existing object (that could be None , if it doesn\u2019t exist yet): Controller from flask import request , render_template from .app import app from .forms import MessageForm from .models import db , Message @app.route ( \"/messages/new/\" , methods = [ \"GET\" , \"POST\" ]) @app.route ( \"/messages/<int:msg_id>/edit/\" , methods = [ \"GET\" , \"POST\" ]) def edit ( msg_id = None ): # Load the message if exists message = None if msg_id : message = db . query ( Message ) . filter_by ( id = msg_id ) . first () form = MessageForm ( request . form , message ) # TODO return render_template ( \"message_edit.html.jinja2\" , form = form , ) Template {% extends \"layout.html\" %} {% block title %} Edit message {% endblock %} {% block content %} < form method = \"post\" action = \"\" > < div class = \"form-group\" > {{ form.your_name.as_input ( label = \"Name:\" ) }} {{ form.your_name.render_error () }} </ div > < div class = \"form-group\" > {{ form.message.as_textarea ( label = \"Message:\" ) }} {{ form.message.render_error () }} </ div > < button type = \"submit\" class = \"btn btn-primary\" > Save </ button > </ form > {% endblock %} [2] Second , we process the input data the user send using the form: from flask import request , render_template , redirect , url_for , flash from .app import app from .forms import MessageForm from .models import db , Message @app.route ( \"/messages/new/\" , methods = [ \"GET\" , \"POST\" ]) @app.route ( \"/messages/<int:msg_id>/edit/\" , methods = [ \"GET\" , \"POST\" ]) def edit ( msg_id = None ): if msg_id : message = db . query ( Message ) . filter_by ( id = msg_id ) . first () else : message = None form = MessageForm ( request . form , message ) # [2] if request . method == 'POST' and form . validate (): # [3] form . save () flash ( \"Message saved.\" , 'success' ) return redirect ( url_for ( \"messages\" )) return render_template ( \"message_edit.html.jinja2\" , form = form , ) Note that we have it so validate() is only called if there is POST data. The reason we gate the validation check this way is that, when there is no POST data (like in step [1]), we don\u2019t want to cause validation errors. If the form was submitted and has errors, it\u2019ll be shown again to the user, only this time with error messages. [3] Finally , if the form is valid, we do something with the data. In this example, form.save() creates/update a Message object in the database. After we finish processing the form, we do a redirect to another page.","title":"Diving into it"},{"location":"faq/","text":"Frequently Asked Questions # Does Proper Form works with ____? # Most likely yes . Request/Form Input # Here are some of the popular libraries to are known to work with Proper Form, but if it\u2019s not listed, it doesn\u2019t mean it won\u2019t work. Django. Werkzeug: Flask, etc. Webob: Pyramid, Morepath, Turbogears, Google App Engine, etc. Any other cgi.FieldStorage -type multidict: Falcon, Bottle, etc. Database ORMs # Pretty much any ORM anything should work, as long as data objects allow attribute access to their members. There is built-in support por SQLAlchemy and PonyORM but writing your own adapter is just a few lines of code. For example, this is the complete code for the adapter to PonyORM: class PonyForm ( Form ): def create_object ( self , data ): return self . _model ( ** data ) def delete_object ( self ): return self . _object . delete () That\u2019s it. What versions of Python are supported? # Python 3.6 and beyond. Is Proper Form an async library? # No. (However, you can use loop.run_in_executor() to run it from asyncio, without blocking the main event loop). I hope that a future version of Python (4?) removes this forced separation, so you can transparently call the same code from sync and async functions (like you do in JavaScript, for example). How can I contribute to Proper Form? # For bugs and feature requests, you can open an issue on the GitHub page . Does Proper Form handle file uploads or image thumbanils? # It does not. Those are concerns for your framework or for other specialized libraries. Proper Form has a File field which will let you render a file input, but it doesn\u2019t do more than that. I have a question not covered in this documentation # Please open an issue on the GitHub page with the tag \u201cquestion\u201d.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#does-proper-form-works-with-____","text":"Most likely yes .","title":"Does Proper Form works with ____?"},{"location":"faq/#requestform-input","text":"Here are some of the popular libraries to are known to work with Proper Form, but if it\u2019s not listed, it doesn\u2019t mean it won\u2019t work. Django. Werkzeug: Flask, etc. Webob: Pyramid, Morepath, Turbogears, Google App Engine, etc. Any other cgi.FieldStorage -type multidict: Falcon, Bottle, etc.","title":"Request/Form Input"},{"location":"faq/#database-orms","text":"Pretty much any ORM anything should work, as long as data objects allow attribute access to their members. There is built-in support por SQLAlchemy and PonyORM but writing your own adapter is just a few lines of code. For example, this is the complete code for the adapter to PonyORM: class PonyForm ( Form ): def create_object ( self , data ): return self . _model ( ** data ) def delete_object ( self ): return self . _object . delete () That\u2019s it.","title":"Database ORMs"},{"location":"faq/#what-versions-of-python-are-supported","text":"Python 3.6 and beyond.","title":"What versions of Python are supported?"},{"location":"faq/#is-proper-form-an-async-library","text":"No. (However, you can use loop.run_in_executor() to run it from asyncio, without blocking the main event loop). I hope that a future version of Python (4?) removes this forced separation, so you can transparently call the same code from sync and async functions (like you do in JavaScript, for example).","title":"Is Proper Form an async library?"},{"location":"faq/#how-can-i-contribute-to-proper-form","text":"For bugs and feature requests, you can open an issue on the GitHub page .","title":"How can I contribute to Proper Form?"},{"location":"faq/#does-proper-form-handle-file-uploads-or-image-thumbanils","text":"It does not. Those are concerns for your framework or for other specialized libraries. Proper Form has a File field which will let you render a file input, but it doesn\u2019t do more than that.","title":"Does Proper Form handle file uploads or image thumbanils?"},{"location":"faq/#i-have-a-question-not-covered-in-this-documentation","text":"Please open an issue on the GitHub page with the tag \u201cquestion\u201d.","title":"I have a question not covered in this documentation"},{"location":"fields/","text":"Fields # A field represent a data type. It handles coercing of the input to that data type and following validations. For example, Text , Integer , Date , and Email are some of the available fields. import proper_form as f class MyForm ( f . Form ): name = f . Text ( required = True ) email = f . Email ( required = True ) birthday = f . Date () Unlike most (all?) the other form libraries, Proper Form doesn\u2019t tie a field to a specific HTML representation. For example, an Email field can be rendered as a <input type=\"email\"> , but also as a <select> , a <input type=\"checkbox\"> , etc. The important part is that the received input is normalized and checked to have the shape of an email address, no matter how the input gets to the field. The most important thing to remember about fields, is that they always take a list of input values, even if only one is sent or needed. All received values are processed even if you only need the first one. It does that for several reasons: You can configure any field to take and return a list of values by setting to True its multiple option. Some special fields work with groups of two separated <input> . For example, a SplittedDateTime expects to receive at least two values with the same name, and cast the first as a date and the second as a time. Can be used by the Confirmed validator to check if a value has been repeated. The classic use is for password confirmation fields. Fields common arguments # Each Field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted: Field ( * validators , ** options ) * validators # Zero or more callables that get the type-casted values and have to return True if is ok or False if not. Proper Form comes with several pre-made validators (see the Validators page), but any custom function or callable object can be used. required ( False ) # By default, each Field class assumes the value is optional, but if you set this option to True , an empty value \u2013 either None or the empty string (\u201c\u201d) \u2013 then validate() will fail. strict ( True ) # By default, if the coercion of the input to the field\u2019s data type fails, validate() will also fail. You can ignore it and continue without that value by setting this option to False . Of course, even if this option is set to False , if all values are invalid and required is True , validate() will still fails for that other reason. multiple ( False ) # Since the input is always a list, and all values are processed, this argument only indicates if the field returns the full list of values or just the first one. In the HTML, you tipically want this to be True for something like a list of checkboxes or a <select multiple> tag. For fields that by default take two values to represent one, like the SplittedDateTime , the values will be processed in pairs . Example: [\"date1\", \"time1\", \"date2\", \"time2\", ] . min_num ( None ) # Validates that the number of values with this name is at least this. max_num ( None ) # Validates that the number of values with this name is at most this. error_messages ( None ) # The required , strict , min_num , and max_num validations fail with this predefined error messages: default_error_messages = { \"required\" : \"This field is required.\" , \"type\" : \"Invalid type.\" , \"min_num\" : \"You need at least {num} values.\" , \"max_num\" : \"You can have at most {num} values.\" , } The error_messages argument allows you to overwrite all or some of these messages by passing a dictionary with your custom error messages for those validations. collection ( False ) # This will treat all inputs as a comma-separated list of values, process them, validate them independently, and join them again at the end. Classic examples are lists of emails or URLs If strict is False , any value that can\u2019t be type-casted is filtered out, so you can end with a valid final result even if some of the input values weren\u2019t. Setting this to True forces multiple to be False , the result will always be comma-separated list of values in a single string. sep ( \",\" ) # I wrote \u201ccomma-separated\u201d, but in fact, a collection will be splitted and joined by whatever character(s) you specify in the sep option. clean ( None ) # Just before the field return the type-casted and validated values, you might want to adjust them a little more. This option allows you to pass a function that recieves the final value, or a list of values, if multiple is True , process it/them in some way and returns it. For redability, instead of passing it as an argument, you can alternatively define a method in the parent form named clean_NAME() for the same effect. class MyForm ( Form ): # as an argument name = Text ( clean = lambda v : v . strip ( \"-\" )) mydate = DateTime () # as method in the parent form def clean_mydate ( self , pyvalue ): # change timezone or something ... return clean_value prepare ( None ) # Some data types, like dates, need to be converted to strings before can be shown in the HTML. You don\u2019t usually have to worry about this because the each field take care of it by default, but in some rare cases, you might need to use your own custom function. This option allows you to pass a function to do that. The function passed as prepare , must take a stored value and return a string. For redability, instead of passing it as an argument, you can alternatively define a method in the parent form named prepare_NAME() for the same effect. class MyForm ( Form ): # as an argument name = Text ( prepare = lambda v : f \"--{v}--\" ) mydate = DateTime () # as method in the parent form def prepare_mydate ( self , pyvalue ): # change timezone or something ... return \"some str value\" Field attributes # The attributes of fields can be useful when rendering fields, specially if you need to do something unusual. name # The name attribute of the field for the HTML form, setted by the parent Form class. required # The same as the attribute. values # List of values, already formatted for showing them in the HTML form. value # The first of the values or an empty string if none is found. Field methods # All field methods are about rendering, so they are covered in the Rendering page Built-in Field classes # Naturally, Proper Form includes several Field classes that represent common data types needs. This section documents each built-in field. Boolean( ) # Boolean ( * validators , ** options ) Normalizes to a True or False value. A value is normalized to False if, stripped and lowercased, is one of \"\" , \"none\" , \"0\" , \"no\" , \"nope\" , \"nah\" , \"off\" , or \"false\" . Otherwise is normalized to True . Date( ) # Date ( * validators , ** options ) Validate that the given values are dates with the format YYYY-MM-dd . Normalizes to a datetime.date value. Shows the stored values using the format YYYY-MM-dd . DateTime( ) # DateTime ( * validators , ** options ) Validate that the given values are dates or datetimes with the format YYYY-MM-dd plus an optional time. The time can be in a 12-hours or 24-hours format, with or without seconds. Normalizes to a datetime.datetime value. Shows the stored values using the format YYYY-MM-dd HH:mm:ss AM/PM or YYYY-MM-dd HH:mm AM/PM if the seconds are zero. Email( ) # Email ( * validators , check_dns = False , allow_smtputf8 = False , ** options ) Validates and normalize an email address using the python-email-validator library. Even if the format is valid, it cannot guarantee that the email is real, so the purpose of this validation is to alert the user of a typing mistake. The normalizations include lowercasing the domain part of the email address (domain names are case-insensitive), and unicode \u201cNFC\u201d normalization of the whole address. check_dns (bool): Check if the domain name in the email address resolves. This still doesn\u2019t guarantee that the email is real, but at least you can discard domain mistypes and completely bogus email addresses. There is nothing to be gained by trying to actually contact an SMTP server, so that\u2019s not done. allow_smtputf8 (bool): Accept non-ASCII characters in the local part of the address (before the @-sign). This is disabled by default because these email addresses require that your mail submission library and the mail servers along the route to the destination, including your own outbound mail server, all support the SMTPUTF8 (RFC 6531) extension. File( ) # File ( * validators , ** options ) A field for rendering an <input type=\"file\"> . Proper Form does not deal with any file handling or validation. Float( ) # Float ( * validators , ** options ) Normalizes to a float value. HexColor( ) # HexColor ( * validators , ** options ) Accepts a color in hex, rgb, or rgba color and normalize it to a hex value of 6 digits or 6 digits plus one for alpha. Examples: \u201c#f2e\u201d \u2192 \u201c#ff22ee\u201d \u201crgb(255, 0, 255)\u201d \u2192 \u201c#ff00ff\u201d \u201crgb(221, 96, 89)\u201d \u2192 \u201c#dd6059\u201d \u201crgba(221, 96, 89, 0.3)\u201d \u2192 \u201c#dd60594c\u201d Integer( ) # Integer ( * validators , ** options ) Normalizes to an integer value. Month( ) # Month ( * validators , ** options ) Validate that the given values are dates with the YYYY-MM format. Example: \u201c1980-07\u201d. Normalizes to a datetime.date value. Shows the stored values using the YYYY-MM format. Password( ) # Password ( * validators , ** options ) A text field. Doesn\u2019t normalize or validates it. Whatever value is accepted by this field is not rendered back to the browser like normal fields. Slug( ) # Slug ( * validators , max_length = 0 , separator = '-' , stopwords = None , regex_pattern = None , replacements = None , lowercase = True , word_boundary = False , entities = True , decimal = True , hexadecimal = True , ** options ) A slug is a short label for something, containing only letters, numbers, underscores, or hyphens. Is tipically used for using a name in a URL. To do the conversion, this field uses the powerful python-slugify library, so it takes the same arguments: max_length (int): output string length separator (str): separator between words stopwords (iterable): words to discount regex_pattern (str): regex pattern for allowed characters replacements (iterable): list of replacement rules e.g. [[\u2018|\u2019, \u2018or\u2019], [\u2018%\u2019, \u2018percent\u2019]] lowercase (bool): activate case sensitivity by setting it to False word_boundary (bool): truncates to end of full words (length may be shorter than max_length) entities (bool): converts html entities to unicode (foo & bar -> foo-bar) decimal (bool): converts html decimal to unicode (\u017d -> \u017d -> z) hexadecimal (bool): converts html hexadecimal to unicode (\u017d -> \u017d -> z) SplittedDateTime( ) # SplittedDateTime ( * validators , ** options ) A Datetime field splitted in a date and a time field (with the same name). The input values are grouped in pairs, with the first one is the date and the second one the time. Validates that the first items of the pairs are dates with the format YYYY-MM-dd , and the seconds are empty strings (which is equivalent to \u201c00:00\u201d) or times in a 12-hours or 24-hours format, with or without seconds. Normalizes to a datetime.datetime value. Shows the date part of the stored values using the format YYYY-MM-dd , and the time parts as HH:mm:ss AM/PM or HH:mm AM/PM if the seconds are zero. Text( ) # Text ( * validators , ** options ) A simple text field that normalize the input by stripping the leading and final spaces. Time( ) # Time ( * validators , ** options ) A 12-hours or 24-hours time field, seconds optional. Examples: \u201c5:03 AM\u201d, \u201c11:00 PM\u201d, \u201c4:20:16 PM. Normalizes to a datetime.time value. Shows the stored value as HH:mm:ss AM/PM or HH:mm AM/PM if the seconds are zero. URL( ) # URL ( * validators , require_tld = False , ** options ) Validates and normalize an URL address. Even if the format is valid, it cannot guarantee that the URL is real. The purpose of this function is to alert the user of a typing mistake. The normalizations include lowercasing (domain names are case-insensitive), and unicode \u201cNFC\u201d normalization. require_tld (bool): Indicates if the domain-name portion of the URL must contain a .tld suffix. Set this to True if you want to disallow domains like localhost .","title":"Fields"},{"location":"fields/#fields","text":"A field represent a data type. It handles coercing of the input to that data type and following validations. For example, Text , Integer , Date , and Email are some of the available fields. import proper_form as f class MyForm ( f . Form ): name = f . Text ( required = True ) email = f . Email ( required = True ) birthday = f . Date () Unlike most (all?) the other form libraries, Proper Form doesn\u2019t tie a field to a specific HTML representation. For example, an Email field can be rendered as a <input type=\"email\"> , but also as a <select> , a <input type=\"checkbox\"> , etc. The important part is that the received input is normalized and checked to have the shape of an email address, no matter how the input gets to the field. The most important thing to remember about fields, is that they always take a list of input values, even if only one is sent or needed. All received values are processed even if you only need the first one. It does that for several reasons: You can configure any field to take and return a list of values by setting to True its multiple option. Some special fields work with groups of two separated <input> . For example, a SplittedDateTime expects to receive at least two values with the same name, and cast the first as a date and the second as a time. Can be used by the Confirmed validator to check if a value has been repeated. The classic use is for password confirmation fields.","title":"Fields"},{"location":"fields/#fields-common-arguments","text":"Each Field class constructor takes at least these arguments. Some Field classes take additional, field-specific arguments, but the following should always be accepted: Field ( * validators , ** options )","title":"Fields common arguments"},{"location":"fields/#validators","text":"Zero or more callables that get the type-casted values and have to return True if is ok or False if not. Proper Form comes with several pre-made validators (see the Validators page), but any custom function or callable object can be used.","title":"*validators"},{"location":"fields/#required-false","text":"By default, each Field class assumes the value is optional, but if you set this option to True , an empty value \u2013 either None or the empty string (\u201c\u201d) \u2013 then validate() will fail.","title":"required (False)"},{"location":"fields/#strict-true","text":"By default, if the coercion of the input to the field\u2019s data type fails, validate() will also fail. You can ignore it and continue without that value by setting this option to False . Of course, even if this option is set to False , if all values are invalid and required is True , validate() will still fails for that other reason.","title":"strict (True)"},{"location":"fields/#multiple-false","text":"Since the input is always a list, and all values are processed, this argument only indicates if the field returns the full list of values or just the first one. In the HTML, you tipically want this to be True for something like a list of checkboxes or a <select multiple> tag. For fields that by default take two values to represent one, like the SplittedDateTime , the values will be processed in pairs . Example: [\"date1\", \"time1\", \"date2\", \"time2\", ] .","title":"multiple (False)"},{"location":"fields/#min_num-none","text":"Validates that the number of values with this name is at least this.","title":"min_num (None)"},{"location":"fields/#max_num-none","text":"Validates that the number of values with this name is at most this.","title":"max_num (None)"},{"location":"fields/#error_messages-none","text":"The required , strict , min_num , and max_num validations fail with this predefined error messages: default_error_messages = { \"required\" : \"This field is required.\" , \"type\" : \"Invalid type.\" , \"min_num\" : \"You need at least {num} values.\" , \"max_num\" : \"You can have at most {num} values.\" , } The error_messages argument allows you to overwrite all or some of these messages by passing a dictionary with your custom error messages for those validations.","title":"error_messages (None)"},{"location":"fields/#collection-false","text":"This will treat all inputs as a comma-separated list of values, process them, validate them independently, and join them again at the end. Classic examples are lists of emails or URLs If strict is False , any value that can\u2019t be type-casted is filtered out, so you can end with a valid final result even if some of the input values weren\u2019t. Setting this to True forces multiple to be False , the result will always be comma-separated list of values in a single string.","title":"collection (False)"},{"location":"fields/#sep","text":"I wrote \u201ccomma-separated\u201d, but in fact, a collection will be splitted and joined by whatever character(s) you specify in the sep option.","title":"sep (\",\")"},{"location":"fields/#clean-none","text":"Just before the field return the type-casted and validated values, you might want to adjust them a little more. This option allows you to pass a function that recieves the final value, or a list of values, if multiple is True , process it/them in some way and returns it. For redability, instead of passing it as an argument, you can alternatively define a method in the parent form named clean_NAME() for the same effect. class MyForm ( Form ): # as an argument name = Text ( clean = lambda v : v . strip ( \"-\" )) mydate = DateTime () # as method in the parent form def clean_mydate ( self , pyvalue ): # change timezone or something ... return clean_value","title":"clean (None)"},{"location":"fields/#prepare-none","text":"Some data types, like dates, need to be converted to strings before can be shown in the HTML. You don\u2019t usually have to worry about this because the each field take care of it by default, but in some rare cases, you might need to use your own custom function. This option allows you to pass a function to do that. The function passed as prepare , must take a stored value and return a string. For redability, instead of passing it as an argument, you can alternatively define a method in the parent form named prepare_NAME() for the same effect. class MyForm ( Form ): # as an argument name = Text ( prepare = lambda v : f \"--{v}--\" ) mydate = DateTime () # as method in the parent form def prepare_mydate ( self , pyvalue ): # change timezone or something ... return \"some str value\"","title":"prepare (None)"},{"location":"fields/#field-attributes","text":"The attributes of fields can be useful when rendering fields, specially if you need to do something unusual.","title":"Field attributes"},{"location":"fields/#name","text":"The name attribute of the field for the HTML form, setted by the parent Form class.","title":"name"},{"location":"fields/#required","text":"The same as the attribute.","title":"required"},{"location":"fields/#values","text":"List of values, already formatted for showing them in the HTML form.","title":"values"},{"location":"fields/#value","text":"The first of the values or an empty string if none is found.","title":"value"},{"location":"fields/#field-methods","text":"All field methods are about rendering, so they are covered in the Rendering page","title":"Field methods"},{"location":"fields/#built-in-field-classes","text":"Naturally, Proper Form includes several Field classes that represent common data types needs. This section documents each built-in field.","title":"Built-in Field classes"},{"location":"fields/#boolean","text":"Boolean ( * validators , ** options ) Normalizes to a True or False value. A value is normalized to False if, stripped and lowercased, is one of \"\" , \"none\" , \"0\" , \"no\" , \"nope\" , \"nah\" , \"off\" , or \"false\" . Otherwise is normalized to True .","title":"Boolean( )"},{"location":"fields/#date","text":"Date ( * validators , ** options ) Validate that the given values are dates with the format YYYY-MM-dd . Normalizes to a datetime.date value. Shows the stored values using the format YYYY-MM-dd .","title":"Date( )"},{"location":"fields/#datetime","text":"DateTime ( * validators , ** options ) Validate that the given values are dates or datetimes with the format YYYY-MM-dd plus an optional time. The time can be in a 12-hours or 24-hours format, with or without seconds. Normalizes to a datetime.datetime value. Shows the stored values using the format YYYY-MM-dd HH:mm:ss AM/PM or YYYY-MM-dd HH:mm AM/PM if the seconds are zero.","title":"DateTime( )"},{"location":"fields/#email","text":"Email ( * validators , check_dns = False , allow_smtputf8 = False , ** options ) Validates and normalize an email address using the python-email-validator library. Even if the format is valid, it cannot guarantee that the email is real, so the purpose of this validation is to alert the user of a typing mistake. The normalizations include lowercasing the domain part of the email address (domain names are case-insensitive), and unicode \u201cNFC\u201d normalization of the whole address. check_dns (bool): Check if the domain name in the email address resolves. This still doesn\u2019t guarantee that the email is real, but at least you can discard domain mistypes and completely bogus email addresses. There is nothing to be gained by trying to actually contact an SMTP server, so that\u2019s not done. allow_smtputf8 (bool): Accept non-ASCII characters in the local part of the address (before the @-sign). This is disabled by default because these email addresses require that your mail submission library and the mail servers along the route to the destination, including your own outbound mail server, all support the SMTPUTF8 (RFC 6531) extension.","title":"Email( )"},{"location":"fields/#file","text":"File ( * validators , ** options ) A field for rendering an <input type=\"file\"> . Proper Form does not deal with any file handling or validation.","title":"File( )"},{"location":"fields/#float","text":"Float ( * validators , ** options ) Normalizes to a float value.","title":"Float( )"},{"location":"fields/#hexcolor","text":"HexColor ( * validators , ** options ) Accepts a color in hex, rgb, or rgba color and normalize it to a hex value of 6 digits or 6 digits plus one for alpha. Examples: \u201c#f2e\u201d \u2192 \u201c#ff22ee\u201d \u201crgb(255, 0, 255)\u201d \u2192 \u201c#ff00ff\u201d \u201crgb(221, 96, 89)\u201d \u2192 \u201c#dd6059\u201d \u201crgba(221, 96, 89, 0.3)\u201d \u2192 \u201c#dd60594c\u201d","title":"HexColor( )"},{"location":"fields/#integer","text":"Integer ( * validators , ** options ) Normalizes to an integer value.","title":"Integer( )"},{"location":"fields/#month","text":"Month ( * validators , ** options ) Validate that the given values are dates with the YYYY-MM format. Example: \u201c1980-07\u201d. Normalizes to a datetime.date value. Shows the stored values using the YYYY-MM format.","title":"Month( )"},{"location":"fields/#password","text":"Password ( * validators , ** options ) A text field. Doesn\u2019t normalize or validates it. Whatever value is accepted by this field is not rendered back to the browser like normal fields.","title":"Password( )"},{"location":"fields/#slug","text":"Slug ( * validators , max_length = 0 , separator = '-' , stopwords = None , regex_pattern = None , replacements = None , lowercase = True , word_boundary = False , entities = True , decimal = True , hexadecimal = True , ** options ) A slug is a short label for something, containing only letters, numbers, underscores, or hyphens. Is tipically used for using a name in a URL. To do the conversion, this field uses the powerful python-slugify library, so it takes the same arguments: max_length (int): output string length separator (str): separator between words stopwords (iterable): words to discount regex_pattern (str): regex pattern for allowed characters replacements (iterable): list of replacement rules e.g. [[\u2018|\u2019, \u2018or\u2019], [\u2018%\u2019, \u2018percent\u2019]] lowercase (bool): activate case sensitivity by setting it to False word_boundary (bool): truncates to end of full words (length may be shorter than max_length) entities (bool): converts html entities to unicode (foo & bar -> foo-bar) decimal (bool): converts html decimal to unicode (\u017d -> \u017d -> z) hexadecimal (bool): converts html hexadecimal to unicode (\u017d -> \u017d -> z)","title":"Slug( )"},{"location":"fields/#splitteddatetime","text":"SplittedDateTime ( * validators , ** options ) A Datetime field splitted in a date and a time field (with the same name). The input values are grouped in pairs, with the first one is the date and the second one the time. Validates that the first items of the pairs are dates with the format YYYY-MM-dd , and the seconds are empty strings (which is equivalent to \u201c00:00\u201d) or times in a 12-hours or 24-hours format, with or without seconds. Normalizes to a datetime.datetime value. Shows the date part of the stored values using the format YYYY-MM-dd , and the time parts as HH:mm:ss AM/PM or HH:mm AM/PM if the seconds are zero.","title":"SplittedDateTime( )"},{"location":"fields/#text","text":"Text ( * validators , ** options ) A simple text field that normalize the input by stripping the leading and final spaces.","title":"Text( )"},{"location":"fields/#time","text":"Time ( * validators , ** options ) A 12-hours or 24-hours time field, seconds optional. Examples: \u201c5:03 AM\u201d, \u201c11:00 PM\u201d, \u201c4:20:16 PM. Normalizes to a datetime.time value. Shows the stored value as HH:mm:ss AM/PM or HH:mm AM/PM if the seconds are zero.","title":"Time( )"},{"location":"fields/#url","text":"URL ( * validators , require_tld = False , ** options ) Validates and normalize an URL address. Even if the format is valid, it cannot guarantee that the URL is real. The purpose of this function is to alert the user of a typing mistake. The normalizations include lowercasing (domain names are case-insensitive), and unicode \u201cNFC\u201d normalization. require_tld (bool): Indicates if the domain-name portion of the URL must contain a .tld suffix. Set this to True if you want to disallow domains like localhost .","title":"URL( )"},{"location":"forms/","text":"Forms # At the heart of Proper Form is the Form class. A form contain your field definitions, delegate validation, take input, and in general function as the glue holding everything together. Form are classes that inherit from the proper_form.Form class. You then create instances of those classes in your controllers, using the request and maybe object data. from proper_form import Form , Email , Password class LoginForm ( Form ): login = Email ( required = True ) password = Password ( required = True ) def login (): form = LoginForm ( request . POST ) if request . method == \"POST\" and form . validate (): ... return render_template ( \"login.html\" , form = form ) Form attributes # Form ( input_data = None , object = None , file_data = None , * , prefix = \"\" ) input_data # A MultiDict containing the data from a form request. Form requests are typically POST requests and many web frameworks returns it under the name request.POST . object # Pre-existing data used to populate the form. This can be a dictionary or an instance of a class, typically an ORM Model. file_data # Optional MultiDict with the file data. In some web frameworks this data can be read from the rest of the POST data, so you don\u2019t need to (or can) include it again here. In other frameworks, like Flask, this data is called request.files . prefix # Optional namespace for the form. Form methods # validate() # [ TODO ] save() # [ TODO ] create_object() # [ TODO ] update_object() # [ TODO ] delete_object() # [ TODO ] load_data() # This method can be used to replace the data passed when instantiating the form. Eg: form = Form () ... form . load_data ( input_data , object_data )","title":"Forms"},{"location":"forms/#forms","text":"At the heart of Proper Form is the Form class. A form contain your field definitions, delegate validation, take input, and in general function as the glue holding everything together. Form are classes that inherit from the proper_form.Form class. You then create instances of those classes in your controllers, using the request and maybe object data. from proper_form import Form , Email , Password class LoginForm ( Form ): login = Email ( required = True ) password = Password ( required = True ) def login (): form = LoginForm ( request . POST ) if request . method == \"POST\" and form . validate (): ... return render_template ( \"login.html\" , form = form )","title":"Forms"},{"location":"forms/#form-attributes","text":"Form ( input_data = None , object = None , file_data = None , * , prefix = \"\" )","title":"Form attributes"},{"location":"forms/#input_data","text":"A MultiDict containing the data from a form request. Form requests are typically POST requests and many web frameworks returns it under the name request.POST .","title":"input_data"},{"location":"forms/#object","text":"Pre-existing data used to populate the form. This can be a dictionary or an instance of a class, typically an ORM Model.","title":"object"},{"location":"forms/#file_data","text":"Optional MultiDict with the file data. In some web frameworks this data can be read from the rest of the POST data, so you don\u2019t need to (or can) include it again here. In other frameworks, like Flask, this data is called request.files .","title":"file_data"},{"location":"forms/#prefix","text":"Optional namespace for the form.","title":"prefix"},{"location":"forms/#form-methods","text":"","title":"Form methods"},{"location":"forms/#validate","text":"[ TODO ]","title":"validate()"},{"location":"forms/#save","text":"[ TODO ]","title":"save()"},{"location":"forms/#create_object","text":"[ TODO ]","title":"create_object()"},{"location":"forms/#update_object","text":"[ TODO ]","title":"update_object()"},{"location":"forms/#delete_object","text":"[ TODO ]","title":"delete_object()"},{"location":"forms/#load_data","text":"This method can be used to replace the data passed when instantiating the form. Eg: form = Form () ... form . load_data ( input_data , object_data )","title":"load_data()"},{"location":"formsets/","text":"Form sets # Form sets are the secret weapon ofthis library. Imagine you have models like this: With most form libraries, you would need to have a page for creating/updating the URLs and, only then, you would be able to create/update the person data. What a waste of time! With a form set, you can create/update the person and its URLs at the same time, in a single form. To do so, you need to create two forms, one for the person data, and other for a website, and connect them like this: class WebPageForm ( Form ): url = URL () title = Text () class PersonForm ( Form ): name = Text () webs = FormSet ( WebPageForm ) a FormSet is a special kind of Field that represents a list of forms, to create or edit several items, in the same page, at once. Now that you have a formset you can iterate over the forms in it and display them as you would with a regular form. In the console: >>> form = PersonForm () >>> list ( form . webs ) [ WebPageForm ] or in a template like this one < div class = \"form-group\" > < label > Name < small > (required) </ small ></ label > {{ form.name.as_input ( class = \"form-control\" ) }} {{ form.name.render_error () }} </ div > < div class = \"row\" > {% for f in form.webs %} < div class = \"col-sm-6\" > {{ f.url.as_input ( class = \"form-control\" , placeholder = \"http://\" ) }} {{ f.url.render_error () }} </ div > < div class = \"col-sm-5\" > {{ f.title.as_input ( class = \"form-control\" , placeholder = \"Title (optional)\" ) }} {{ f.title.render_error () }} </ div > {% - endfor %} </ div > \u2026 that renders into < div class = \"form-group\" > < label > Name < small > (required) </ small ></ label > < input class = \"form-control\" name = \"name\" type = \"text\" value = \"\" > </ div > < div class = \"row\" > < div class = \"col-sm-6\" > < input class = \"form-control\" name = \"url\" placeholder = \"http://\" type = \"url\" value = \"\" > </ div > < div class = \"col-sm-5\" > < input class = \"form-control\" name = \"title\" placeholder = \"Title (optional)\" type = \"text\" value = \"\" > </ div > </ div > As you can see it only displayed one, empty, WebPageForm . It creates one for each item in the input or object data (and we have none), plus the value of the extra attribute, that is one by default. You can set it to 0 or to a larger number to change that. >>> class PersonForm ( Form ): ... webs = FormSet ( WebPageForm , extra = 3 ) >>> list ( PersonForm () . webs ) [ WebPageForm , WebPageForm , WebPageForm ] Iterating over the formset will render the forms in the order they were created. FormSets can also be indexed into, which returns the corresponding form. Using object data with a formset # As shown above you can define the number of extra forms. What this means is that you are telling the formset how many additional forms to show in addition to the number of forms it generates from the object data. Let\u2019s take a look at an example: >>> class WebPageForm ( Form ): ... url = URL () ... title = Text () >>> class PersonForm ( Form ): ... name = Text () ... webs = FormSet ( WebPageForm ) >>> form = PersonForm ( object = { ... \"webs\" : [ ... { \"id\" : 1 , \"url\" : \"http://example.com/1\" , \"title\" : \"Example 1\" }, ... { \"id\" : 2 , \"url\" : \"http://example.com/2\" , \"title\" : \"Example 2\" }, ... ] ... }) >>> list ( form . webs ) [ WebPageForm , WebPageForm , WebPageForm ] >>> form . webs [ 1 ] . url . name 'webs--2--url' There are now a total of three forms showing above. Two for the object data that was passed in and one extra form. Also note the format of the HTML names of the fields in the forms of the formset. It follows this format: form_prefix . formset_name -- OBJECT_ID -- field_name Notice how this imply each object must have a distinct ID, even if the data comes as dictionaries. Why Proper Form doesn\u2019t use a a simple counter, like the rest of form libraries? The answer it\u2019s to protect you from race conditions . You want to update a specific object, not just \u201cthe second object from the list\u201d, because there is no guarantee the list hasn\u2019t changed while the form was filled by the user. Using IDs guarantees that you are updating the object you wanted to, even if is not in the same order as before. Note \u201cBut\u2026 what if the user manually change the IDs in the names? Would they be able to change the data of any other objects, like the one from another users?!\u201d No, don\u2019t worry! Proper Form ignore any ID that isn\u2019t in the current list of objects. This feature prevents anyone to access/update data they shouldn\u2019t. Note In the example we are passing in a list of dictionaries as the object data, but the most common scenario will be using the result of a query using an ORM. In any case, it makes no difference. Using input data with a formset # A formset can accept any number of new forms. A \u201cnew form\u201d are those that aren\u2019t created for editing an existing object, but added client side. To do so, the names of the fields must follow this pattern: prefix . formset_name -- _NEWx -- field_name where \u201cx\u201d is a number shared by all the fields of a form. They doesn\u2019t have to be correlative, but they must be different for each form, example: webs -- _NEW1 -- url webs -- _NEW1 -- title webs -- _NEW2 -- url webs -- _NEW2 -- title webs -- _NEW3 -- url webs -- _NEW3 -- title If you create a formset with can_create=False , all the new forms are ignored. Deleting existing forms # Formsets monitor the presence of a special name to know if it has to delete a form and, more importantly, its related object. Not including the form fields doesn\u2019t do anything, to actually delete its object you must send to the form field with a name that follows this pattern: prefix . formset_name -- OBJECT_ID -- _DELETED If you create a formset with can_delete=False , this special name is ignored. Arguments # FormSet ( FormClass , backref = None , extra = 1 , min_num = None , max_num = None , can_delete = True , can_create = True , error_messages = None , ) FormClass # backref ( None ) # If your forms inside the formset have a _model attribute, they will update/create rows in a database when saving the parent form, as expected. When that\u2019s the case, the backref attribute is something you might need to add. Without backref # Without a backref attribute, Proper Form will try to save the child forms first, and them assign the list of them to the parent form. If you are dealing with models instead of dictionaries, your database might not like that. In the example above, a WebPage model will have a non-nullable person_id field. If we save those forms first, you will not have yet a person to get the ID from, so the save operation is going to fail. We\u2019ll need to create a person first, and then create the child objects using the person as an argument. With backref # # Possible SQLAlchemy models class WebPage ( Model ): url = Column ( Text ) title = Column ( Text ) owner_id = Column ( Integer , ForeignKey ( \"owner.id\" )) owner = relationship ( \"Person\" , back_populates = \"webs\" ) class Person ( Model ): name = Column ( Text ) A backref is how the child models call its parents, in this example, is \u201cowner\u201d, so we use that as a backref attribute: class WebPageForm ( Form ): url = URL () title = Text () class PersonForm ( Form ): name = Text () webs = FormSet ( WebPageForm , backref = \"owner\" ) When Proper Form receives a backref , it reverse the order of the form saving. Now first it creates the parent object, and then the child objects using the parent object as an attribute. In this way, no database constraints are broken and the saving of the form finish without problems. extra ( 1 ) # Number of extra empty forms added to the list, even if there is no data available. min_num ( None ) # Validates that the number of sub-forms, existing plus new, is at least this. max_num ( None ) # Validates that the number of sub-forms, existing plus new, is at most this. can_delete ( True ) # If this option is False , the special name to delete a form is ignored and no objects are deleted. can_create ( True ) # If this option is False , the data from all new forms is ignored. You can only use the formset to edit the data of pre-existing objects. error_messages ( None ) # The min_num , and max_num validations fail with this predefined error messages: default_error_messages = { \"min_num\" : \"Please submit at least {num} forms.\" , \"max_num\" : \"Please submit at most {num} forms.\" , } The error_messages argument allows you to overwrite all or one of these messages by passing a dictionary with your custom error messages for those validations. Adding new forms with JavaScript # [ TODO ]","title":"Form sets"},{"location":"formsets/#form-sets","text":"Form sets are the secret weapon ofthis library. Imagine you have models like this: With most form libraries, you would need to have a page for creating/updating the URLs and, only then, you would be able to create/update the person data. What a waste of time! With a form set, you can create/update the person and its URLs at the same time, in a single form. To do so, you need to create two forms, one for the person data, and other for a website, and connect them like this: class WebPageForm ( Form ): url = URL () title = Text () class PersonForm ( Form ): name = Text () webs = FormSet ( WebPageForm ) a FormSet is a special kind of Field that represents a list of forms, to create or edit several items, in the same page, at once. Now that you have a formset you can iterate over the forms in it and display them as you would with a regular form. In the console: >>> form = PersonForm () >>> list ( form . webs ) [ WebPageForm ] or in a template like this one < div class = \"form-group\" > < label > Name < small > (required) </ small ></ label > {{ form.name.as_input ( class = \"form-control\" ) }} {{ form.name.render_error () }} </ div > < div class = \"row\" > {% for f in form.webs %} < div class = \"col-sm-6\" > {{ f.url.as_input ( class = \"form-control\" , placeholder = \"http://\" ) }} {{ f.url.render_error () }} </ div > < div class = \"col-sm-5\" > {{ f.title.as_input ( class = \"form-control\" , placeholder = \"Title (optional)\" ) }} {{ f.title.render_error () }} </ div > {% - endfor %} </ div > \u2026 that renders into < div class = \"form-group\" > < label > Name < small > (required) </ small ></ label > < input class = \"form-control\" name = \"name\" type = \"text\" value = \"\" > </ div > < div class = \"row\" > < div class = \"col-sm-6\" > < input class = \"form-control\" name = \"url\" placeholder = \"http://\" type = \"url\" value = \"\" > </ div > < div class = \"col-sm-5\" > < input class = \"form-control\" name = \"title\" placeholder = \"Title (optional)\" type = \"text\" value = \"\" > </ div > </ div > As you can see it only displayed one, empty, WebPageForm . It creates one for each item in the input or object data (and we have none), plus the value of the extra attribute, that is one by default. You can set it to 0 or to a larger number to change that. >>> class PersonForm ( Form ): ... webs = FormSet ( WebPageForm , extra = 3 ) >>> list ( PersonForm () . webs ) [ WebPageForm , WebPageForm , WebPageForm ] Iterating over the formset will render the forms in the order they were created. FormSets can also be indexed into, which returns the corresponding form.","title":"Form sets"},{"location":"formsets/#using-object-data-with-a-formset","text":"As shown above you can define the number of extra forms. What this means is that you are telling the formset how many additional forms to show in addition to the number of forms it generates from the object data. Let\u2019s take a look at an example: >>> class WebPageForm ( Form ): ... url = URL () ... title = Text () >>> class PersonForm ( Form ): ... name = Text () ... webs = FormSet ( WebPageForm ) >>> form = PersonForm ( object = { ... \"webs\" : [ ... { \"id\" : 1 , \"url\" : \"http://example.com/1\" , \"title\" : \"Example 1\" }, ... { \"id\" : 2 , \"url\" : \"http://example.com/2\" , \"title\" : \"Example 2\" }, ... ] ... }) >>> list ( form . webs ) [ WebPageForm , WebPageForm , WebPageForm ] >>> form . webs [ 1 ] . url . name 'webs--2--url' There are now a total of three forms showing above. Two for the object data that was passed in and one extra form. Also note the format of the HTML names of the fields in the forms of the formset. It follows this format: form_prefix . formset_name -- OBJECT_ID -- field_name Notice how this imply each object must have a distinct ID, even if the data comes as dictionaries. Why Proper Form doesn\u2019t use a a simple counter, like the rest of form libraries? The answer it\u2019s to protect you from race conditions . You want to update a specific object, not just \u201cthe second object from the list\u201d, because there is no guarantee the list hasn\u2019t changed while the form was filled by the user. Using IDs guarantees that you are updating the object you wanted to, even if is not in the same order as before. Note \u201cBut\u2026 what if the user manually change the IDs in the names? Would they be able to change the data of any other objects, like the one from another users?!\u201d No, don\u2019t worry! Proper Form ignore any ID that isn\u2019t in the current list of objects. This feature prevents anyone to access/update data they shouldn\u2019t. Note In the example we are passing in a list of dictionaries as the object data, but the most common scenario will be using the result of a query using an ORM. In any case, it makes no difference.","title":"Using object data with a formset"},{"location":"formsets/#using-input-data-with-a-formset","text":"A formset can accept any number of new forms. A \u201cnew form\u201d are those that aren\u2019t created for editing an existing object, but added client side. To do so, the names of the fields must follow this pattern: prefix . formset_name -- _NEWx -- field_name where \u201cx\u201d is a number shared by all the fields of a form. They doesn\u2019t have to be correlative, but they must be different for each form, example: webs -- _NEW1 -- url webs -- _NEW1 -- title webs -- _NEW2 -- url webs -- _NEW2 -- title webs -- _NEW3 -- url webs -- _NEW3 -- title If you create a formset with can_create=False , all the new forms are ignored.","title":"Using input data with a formset"},{"location":"formsets/#deleting-existing-forms","text":"Formsets monitor the presence of a special name to know if it has to delete a form and, more importantly, its related object. Not including the form fields doesn\u2019t do anything, to actually delete its object you must send to the form field with a name that follows this pattern: prefix . formset_name -- OBJECT_ID -- _DELETED If you create a formset with can_delete=False , this special name is ignored.","title":"Deleting existing forms"},{"location":"formsets/#arguments","text":"FormSet ( FormClass , backref = None , extra = 1 , min_num = None , max_num = None , can_delete = True , can_create = True , error_messages = None , )","title":"Arguments"},{"location":"formsets/#formclass","text":"","title":"FormClass"},{"location":"formsets/#backref-none","text":"If your forms inside the formset have a _model attribute, they will update/create rows in a database when saving the parent form, as expected. When that\u2019s the case, the backref attribute is something you might need to add.","title":"backref (None)"},{"location":"formsets/#without-backref","text":"Without a backref attribute, Proper Form will try to save the child forms first, and them assign the list of them to the parent form. If you are dealing with models instead of dictionaries, your database might not like that. In the example above, a WebPage model will have a non-nullable person_id field. If we save those forms first, you will not have yet a person to get the ID from, so the save operation is going to fail. We\u2019ll need to create a person first, and then create the child objects using the person as an argument.","title":"Without backref"},{"location":"formsets/#with-backref","text":"# Possible SQLAlchemy models class WebPage ( Model ): url = Column ( Text ) title = Column ( Text ) owner_id = Column ( Integer , ForeignKey ( \"owner.id\" )) owner = relationship ( \"Person\" , back_populates = \"webs\" ) class Person ( Model ): name = Column ( Text ) A backref is how the child models call its parents, in this example, is \u201cowner\u201d, so we use that as a backref attribute: class WebPageForm ( Form ): url = URL () title = Text () class PersonForm ( Form ): name = Text () webs = FormSet ( WebPageForm , backref = \"owner\" ) When Proper Form receives a backref , it reverse the order of the form saving. Now first it creates the parent object, and then the child objects using the parent object as an attribute. In this way, no database constraints are broken and the saving of the form finish without problems.","title":"With backref"},{"location":"formsets/#extra-1","text":"Number of extra empty forms added to the list, even if there is no data available.","title":"extra (1)"},{"location":"formsets/#min_num-none","text":"Validates that the number of sub-forms, existing plus new, is at least this.","title":"min_num (None)"},{"location":"formsets/#max_num-none","text":"Validates that the number of sub-forms, existing plus new, is at most this.","title":"max_num (None)"},{"location":"formsets/#can_delete-true","text":"If this option is False , the special name to delete a form is ignored and no objects are deleted.","title":"can_delete (True)"},{"location":"formsets/#can_create-true","text":"If this option is False , the data from all new forms is ignored. You can only use the formset to edit the data of pre-existing objects.","title":"can_create (True)"},{"location":"formsets/#error_messages-none","text":"The min_num , and max_num validations fail with this predefined error messages: default_error_messages = { \"min_num\" : \"Please submit at least {num} forms.\" , \"max_num\" : \"Please submit at most {num} forms.\" , } The error_messages argument allows you to overwrite all or one of these messages by passing a dictionary with your custom error messages for those validations.","title":"error_messages (None)"},{"location":"formsets/#adding-new-forms-with-javascript","text":"[ TODO ]","title":"Adding new forms with JavaScript"},{"location":"orm/","text":"ORM integration # Proper Form can update/create/destroy entries in your database automatically, even for the forms inside a formset. There is built-in support por SQLAlchemy and PonyORM but writing your own adapter is just a few lines of code. SQLAlchemy # Requires that your forms: Have a _model attribute with the Model class. Inherit from SQLAForm instead of from Form . Have a _session property or attribute that returns the database session Example, with Flask-SQLAlchemy : from proper_form import SQLAForm , Text from .models import db , MyModel , AnotherModel class BaseForm ( SQLAForm ): _session = db . session class MyForm ( BaseForm ): _model = MyModel lorem = Text () class AnotherForm ( BaseForm ): _model = AnotherModel ipsum = Text () With \u201craw\u201d SQLAlxhemy the base form might be something like this: class BaseForm ( SQLAForm ): @property def _session ( self ): return Session () PonyORM # Requires that your forms: Have a _model attribute with the Model class. Inherit from PonyForm instead of from Form . Example: from proper_form import PonyForm , Text from .models import db , MyModel , AnotherModel class BaseForm ( PonyForm ): pass class MyForm ( BaseForm ): _model = MyModel lorem = Text () class AnotherForm ( BaseForm ): _model = AnotherModel ipsum = Text () Writing your own adapters (a.k.a. how it works) # Your forms has three methods that an adapter can overwrite to work. These are: def create_object ( self , data ): ... def delete_object ( self ): ... def update_object ( self , data ): for key , value in data . items (): setattr ( self . _object , key , value ) return self . _object self._object is the original object passed as an argument. delete_object and update_object will not be called if there isn\u2019t one. You might not need to write the three methods, in fact, the built-in adapters for SQLAlchemy an PonyORm only ovewrite the create_object and delete_object methods. This is the complete (and incredible short) code for the built-in adapters: from proper_form import Form class PonyForm ( Form ): def create_object ( self , data ): return self . _model ( ** data ) def delete_object ( self ): return self . _object . delete () class SQLAForm ( Form ): def create_object ( self , data ): object = self . _model ( ** data ) self . _session . add ( object ) return object def delete_object ( self ): return self . _session . delete ( self . _object ) Using the three methods it should be possible to write an adapter to anything , even something different than an ORM, like raw SQL, a NoSQL database, or something more exotic.","title":"ORM integration"},{"location":"orm/#orm-integration","text":"Proper Form can update/create/destroy entries in your database automatically, even for the forms inside a formset. There is built-in support por SQLAlchemy and PonyORM but writing your own adapter is just a few lines of code.","title":"ORM integration"},{"location":"orm/#sqlalchemy","text":"Requires that your forms: Have a _model attribute with the Model class. Inherit from SQLAForm instead of from Form . Have a _session property or attribute that returns the database session Example, with Flask-SQLAlchemy : from proper_form import SQLAForm , Text from .models import db , MyModel , AnotherModel class BaseForm ( SQLAForm ): _session = db . session class MyForm ( BaseForm ): _model = MyModel lorem = Text () class AnotherForm ( BaseForm ): _model = AnotherModel ipsum = Text () With \u201craw\u201d SQLAlxhemy the base form might be something like this: class BaseForm ( SQLAForm ): @property def _session ( self ): return Session ()","title":"SQLAlchemy"},{"location":"orm/#ponyorm","text":"Requires that your forms: Have a _model attribute with the Model class. Inherit from PonyForm instead of from Form . Example: from proper_form import PonyForm , Text from .models import db , MyModel , AnotherModel class BaseForm ( PonyForm ): pass class MyForm ( BaseForm ): _model = MyModel lorem = Text () class AnotherForm ( BaseForm ): _model = AnotherModel ipsum = Text ()","title":"PonyORM"},{"location":"orm/#writing-your-own-adapters-aka-how-it-works","text":"Your forms has three methods that an adapter can overwrite to work. These are: def create_object ( self , data ): ... def delete_object ( self ): ... def update_object ( self , data ): for key , value in data . items (): setattr ( self . _object , key , value ) return self . _object self._object is the original object passed as an argument. delete_object and update_object will not be called if there isn\u2019t one. You might not need to write the three methods, in fact, the built-in adapters for SQLAlchemy an PonyORm only ovewrite the create_object and delete_object methods. This is the complete (and incredible short) code for the built-in adapters: from proper_form import Form class PonyForm ( Form ): def create_object ( self , data ): return self . _model ( ** data ) def delete_object ( self ): return self . _object . delete () class SQLAForm ( Form ): def create_object ( self , data ): object = self . _model ( ** data ) self . _session . add ( object ) return object def delete_object ( self ): return self . _session . delete ( self . _object ) Using the three methods it should be possible to write an adapter to anything , even something different than an ORM, like raw SQL, a NoSQL database, or something more exotic.","title":"Writing your own adapters (a.k.a. how it works)"},{"location":"rendering/","text":"Rendering # Instead of rendering a form with a predefined static markup, wih Proper Form you render its individual fields. For example: < form method = \"post\" action = \"\" > {{ form.render_error () }} < div class = \"col\" > {{ form.myname.as_input ( label = \"Name:\" ) }} {{ form.myname.render_error () }} </ div > < div class = \"col\" > {{ form.myemail.as_input ( label = \"Email:\" ) }} {{ form.myemail.render_error () }} </ div > </ form > that will render to: < form method = \"post\" action = \"\" > < div class = \"col\" > < label for = \"myname\" > Name: </ label > < input id = \"myname\" name = \"myname\" type = \"text\" > </ div > < div class = \"col\" > < label for = \"myemail\" > Email: </ label > < input id = \"myemail\" name = \"myemail\" type = \"email\" > </ div > </ form > As in the example, the usual thing to do is to also to add the rendering code for the field error right below (or at the top) of it. If there is no error nothing will be rendered there anyway. The form can also have a form.error attribute manually set by you. Available methods # One of the thing Proper Form does different is that it doesn\u2019t tie a field type to a specific HTML tag. You might think an URL field it\u2019s always going to be displayed as an <input> , but it doesn\u2019t have to . You could also have URLs as values of checkboxes, radio buttons, or selects. For that reason, all of these method are available for all fields, no matter its data type. About HTML attributes # All of these methods accept any number of key=value optional arguments. These\u2019ll be included as HTML attributes. Use className instead of class . >>> field . as_input ( className = \"someclass anotherone\" , zzz = \"bar\" ) '<input class=\"someclass anotherone\" name=\"field\" type=\"text\" zzz=\"bar\">' If you need an attribute with a dash, like data-id , use an underscore data_id=123 . For properties (attributes without values) just use True as its value. >>> field . as_input ( data_id = 123 , data_target = True ) '<input data_id=\"123\" name=\"field\" type=\"text\" data-target>' as_input( ) # field . as_input ( label = None , ** attrs ) Renders the field as a <input type=\"text\"> element, although the type can be overwritten. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). Examples: >>> form . url . as_input () '<input name=\"url\" type=\"url\">' # If the field has `required=True' >>> form . url . as_input () '<input name=\"url\" type=\"url\" required>' >>> form . url . as_input ( type = \"text\" , className = \"form-control\" ) '<input class=\"form-control\" name=\"url\" type=\"text\">' >>> form . url . as_input ( label = \"Webpage:\" ) '<label for=\"url\">Webpage:</label> \\n <input id=\"url\" name=\"url\" type=\"url\">' >>> form . url . as_input ( label = \"Webpage:\" , id = \"12345\" ) '<label for=\"12345\">Webpage:</label> \\n <input id=\"12345\" name=\"url\" type=\"url\">' as_textarea( ) # field . as_textarea ( label = None , ** attrs ) Renders the field as a <textarea> element. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). Examples: >>> form . bio . as_textarea () '<textarea name=\"bio\"></textarea>' >>> form . bio . as_textarea ( className = \"form-control\" ) '<textarea class=\"form-control\" name=\"bio\"></textarea>' >>> form . bio . as_textarea ( label = \"Your bio:\" ) '<label for=\"bio\">Your bio:</label> \\n <textarea id=\"bio\" name=\"bio\"></textarea>' as_checkbox( ) # field . as_checkbox ( label = None , ** attrs ) Renders the field as a <input type=\"checkbox\"> element. If you use a label argument, a <label> will be added surrounding the input with a class \u201ccheckbox\u201d and the text after the checkbox. Examples: >>> form . tos . as_checkbox () '<input name=\"tos\" type=\"checkbox\">' >>> form . tos . as_checkbox ( className = \"form-control\" ) '<input class=\"form-control\" name=\"tos\" type=\"checkbox\">' >>> form . tos . as_checkbox ( label = \"I didn\u2019t read this\" ) '<label class=\"checkbox\"><input name=\"tos\" type=\"checkbox\"> I didn\u2019t read this</label>' as_radio( ) # field . as_radio ( label = None , ** attrs ) Renders the field as a single <input type=\"radio\"> element. If you use a label argument, a <label> will be added surrounding the input with a class \u201cradio\u201d and the text after the radio button. Examples: >>> form . size . as_radio () '<input name=\"size\" type=\"radio\">' >>> form . size . as_radio ( className = \"form-control\" ) '<input class=\"form-control\" name=\"size\" type=\"radio\">' >>> form . size . as_radio ( label = \"XL\" ) '<label class=\"radio\"><input name=\"size\" type=\"radio\"> XL</label>' as_select_tag( ) # field . as_select_tag ( label = None , ** attrs ) Renders just the opening <select> tag for a field, not any options nor the closing \u201c \u201c. This is intended to be used with <option> tags writted by hand or genereated by other means. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). Examples: >>> form . city . as_select_tag () '<select name=\"city\">' # If the field has `multiple=True` >>> form . city . as_select_tag () '<select name=\"city\" multiple>' >>> form . city . as_select_tag ( className = \"form-control\" ) '<select class=\"form-control\" name=\"city\">' >>> form . city . as_select_tag ( label = \"Choose a city\" ) '<label for=\"city\">Choose a city</label> \\n <select name=\"city\">' as_select( ) # field . as_select ( items , label = None , ** attrs ) Renders the field as a <select> element. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). The items argument is a list that can have two type of elements: A tuple of label, value for rendering as an <option> . A tuple of a label and another list of tuples: (label, [(label, value), ...]) . This will be rendered as an <optgroup> with the label as the title and the items in the list as <option> s inside that group. You can mix the two types of elements to have first-level <option> and <optgroup> s in the same <select> . Example: >>> items = [ ... ( \"Sidney\" , 21 ), ... ( \"Tokyo\" , 22 ), ... \"America\" , [ ... ( \"New York\" , 1 ), ... ( \"San Francisco\" , 2 ), ... ( \"Buenos Aires\" , 3 ), ... ( \"Lima\" , 4 ), ... ( \"Bogota\" , 5 ), ... ], ... \"Europe\" , [ ... ( \"Rome\" , 6 ), ... ( \"London\" , 7 ), ... ( \"Madrid\" , 8 ), ... ( \"Paris\" , 9 ), ... ( \"Berlin\" , 10 ), ... ], ... ] >>> form . city . as_select ( items , label = \"Choose a city:\" ) ''' <label for=\"city\">Choose a city:</label> <select id=\"city\" name=\"city\"> <option value=\"\">Sidney</option> <option value=\"\">Tokyo</option> <optgroup label=\"America\"> <option value=\"1\">New York</option> <option value=\"2\">San Francisco</option> <option value=\"3\">Buenos Aires</option> <option value=\"4\">Lima</option> <option value=\"5\">Bogota</option> </optgroup> <optgroup label=\"Europe\"> <option value=\"6\">Rome</option> <option value=\"7\">London</option> <option value=\"8\">Madrid</option> <option value=\"9\">Paris</option> <option value=\"10\">Berlin</option> </optgroup> </select> ''' render_optgroup( ) # field . render_optgroup ( label , items , ** attrs ) Renders an <optgroup> tag with <options> . Used by as_select() to render its groups, but you can call it yourself to build your options list by hand. The label is the title of the group and items is a list of label, value tuples for the options. Example: >>> items = [ ... ( \"Rome\" , 6 ), ... ( \"London\" , 7 ), ... ( \"Madrid\" , 8 ), ... ( \"Paris\" , 9 ), ... ( \"Berlin\" , 10 ), ... ] >>> form . city . render_optgroup ( \"Europe\" , items ) ''' <optgroup label=\"Europe\"> <option value=\"6\">Rome</option> <option value=\"7\">London</option> <option value=\"8\">Madrid</option> <option value=\"9\">Paris</option> <option value=\"10\">Berlin</option> </optgroup> ''' render_option( ) # field . render_option ( label , value = None , ** attrs ) Renders an <option> element. Used by as_select() and by render_optgroup() to render its options, but you can call it yourself to build your options list by hand. If you omit the value, the label will be used as a value as well. Examples: >>> form . city . render_option ( \"Lima\" ) '<option value=\"Lima\">Lima</option>' >>> form . city . render_option ( \"Lima\" , 123 ) '<option value=\"123\">Lima</option>' >>> form . city . render_option ( \"Lima\" , \"LIM\" , data_color = \"orange\" ) '<option value=\"LIM\" data-color=\"orange\">Lima</option>' render_error( ) # field . render_error ( tag = \"div\" , ** attrs ) If the field has an error, this methods renders a tag (a <div> by default)with an \u201cerror\u201d class and the error message. Both the tag and the class can be overwritten. If the field has no error, nothing is rendered. Examples: # If the field has a `required` error >>> form . email . render_error () '<div class=\"error\">This field is required</div>' # Custom tag and class >>> form . email . render_error ( tag = \"p\" , className = \"errorMessage\" ) '<p class=\"errorMessage\">This field is required</p>' # If the field has no error >>> form . name . render_error () '' Using form templates # Proper Form doesn\u2019t have a default form.render() method, but you can write one yourself on each of your forms or, better yet, in a base form. For example you could have a separated template for each if your forms in a templates/forms/ folder: from flask import render_template from proper_form import Form class BaseForm ( Form ): def render ( self ): name = self . __class__ . __name__ . lower () tmpl = f \"forms/{name}.html.jinja2\" return render_template ( tmpl , form = self ) If you make all of your forms inherit from that base form, you will now be able of rendering a form just calling its .render() method. class MyForm ( BaseForm ): name = Text () ... <p>lorem ipsum</p> {{ myform.render () }} <p>lorem ipsum</p>","title":"Rendering"},{"location":"rendering/#rendering","text":"Instead of rendering a form with a predefined static markup, wih Proper Form you render its individual fields. For example: < form method = \"post\" action = \"\" > {{ form.render_error () }} < div class = \"col\" > {{ form.myname.as_input ( label = \"Name:\" ) }} {{ form.myname.render_error () }} </ div > < div class = \"col\" > {{ form.myemail.as_input ( label = \"Email:\" ) }} {{ form.myemail.render_error () }} </ div > </ form > that will render to: < form method = \"post\" action = \"\" > < div class = \"col\" > < label for = \"myname\" > Name: </ label > < input id = \"myname\" name = \"myname\" type = \"text\" > </ div > < div class = \"col\" > < label for = \"myemail\" > Email: </ label > < input id = \"myemail\" name = \"myemail\" type = \"email\" > </ div > </ form > As in the example, the usual thing to do is to also to add the rendering code for the field error right below (or at the top) of it. If there is no error nothing will be rendered there anyway. The form can also have a form.error attribute manually set by you.","title":"Rendering"},{"location":"rendering/#available-methods","text":"One of the thing Proper Form does different is that it doesn\u2019t tie a field type to a specific HTML tag. You might think an URL field it\u2019s always going to be displayed as an <input> , but it doesn\u2019t have to . You could also have URLs as values of checkboxes, radio buttons, or selects. For that reason, all of these method are available for all fields, no matter its data type.","title":"Available methods"},{"location":"rendering/#about-html-attributes","text":"All of these methods accept any number of key=value optional arguments. These\u2019ll be included as HTML attributes. Use className instead of class . >>> field . as_input ( className = \"someclass anotherone\" , zzz = \"bar\" ) '<input class=\"someclass anotherone\" name=\"field\" type=\"text\" zzz=\"bar\">' If you need an attribute with a dash, like data-id , use an underscore data_id=123 . For properties (attributes without values) just use True as its value. >>> field . as_input ( data_id = 123 , data_target = True ) '<input data_id=\"123\" name=\"field\" type=\"text\" data-target>'","title":"About HTML attributes"},{"location":"rendering/#as_input","text":"field . as_input ( label = None , ** attrs ) Renders the field as a <input type=\"text\"> element, although the type can be overwritten. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). Examples: >>> form . url . as_input () '<input name=\"url\" type=\"url\">' # If the field has `required=True' >>> form . url . as_input () '<input name=\"url\" type=\"url\" required>' >>> form . url . as_input ( type = \"text\" , className = \"form-control\" ) '<input class=\"form-control\" name=\"url\" type=\"text\">' >>> form . url . as_input ( label = \"Webpage:\" ) '<label for=\"url\">Webpage:</label> \\n <input id=\"url\" name=\"url\" type=\"url\">' >>> form . url . as_input ( label = \"Webpage:\" , id = \"12345\" ) '<label for=\"12345\">Webpage:</label> \\n <input id=\"12345\" name=\"url\" type=\"url\">'","title":"as_input( )"},{"location":"rendering/#as_textarea","text":"field . as_textarea ( label = None , ** attrs ) Renders the field as a <textarea> element. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). Examples: >>> form . bio . as_textarea () '<textarea name=\"bio\"></textarea>' >>> form . bio . as_textarea ( className = \"form-control\" ) '<textarea class=\"form-control\" name=\"bio\"></textarea>' >>> form . bio . as_textarea ( label = \"Your bio:\" ) '<label for=\"bio\">Your bio:</label> \\n <textarea id=\"bio\" name=\"bio\"></textarea>'","title":"as_textarea( )"},{"location":"rendering/#as_checkbox","text":"field . as_checkbox ( label = None , ** attrs ) Renders the field as a <input type=\"checkbox\"> element. If you use a label argument, a <label> will be added surrounding the input with a class \u201ccheckbox\u201d and the text after the checkbox. Examples: >>> form . tos . as_checkbox () '<input name=\"tos\" type=\"checkbox\">' >>> form . tos . as_checkbox ( className = \"form-control\" ) '<input class=\"form-control\" name=\"tos\" type=\"checkbox\">' >>> form . tos . as_checkbox ( label = \"I didn\u2019t read this\" ) '<label class=\"checkbox\"><input name=\"tos\" type=\"checkbox\"> I didn\u2019t read this</label>'","title":"as_checkbox( )"},{"location":"rendering/#as_radio","text":"field . as_radio ( label = None , ** attrs ) Renders the field as a single <input type=\"radio\"> element. If you use a label argument, a <label> will be added surrounding the input with a class \u201cradio\u201d and the text after the radio button. Examples: >>> form . size . as_radio () '<input name=\"size\" type=\"radio\">' >>> form . size . as_radio ( className = \"form-control\" ) '<input class=\"form-control\" name=\"size\" type=\"radio\">' >>> form . size . as_radio ( label = \"XL\" ) '<label class=\"radio\"><input name=\"size\" type=\"radio\"> XL</label>'","title":"as_radio( )"},{"location":"rendering/#as_select_tag","text":"field . as_select_tag ( label = None , ** attrs ) Renders just the opening <select> tag for a field, not any options nor the closing \u201c \u201c. This is intended to be used with <option> tags writted by hand or genereated by other means. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). Examples: >>> form . city . as_select_tag () '<select name=\"city\">' # If the field has `multiple=True` >>> form . city . as_select_tag () '<select name=\"city\" multiple>' >>> form . city . as_select_tag ( className = \"form-control\" ) '<select class=\"form-control\" name=\"city\">' >>> form . city . as_select_tag ( label = \"Choose a city\" ) '<label for=\"city\">Choose a city</label> \\n <select name=\"city\">'","title":"as_select_tag( )"},{"location":"rendering/#as_select","text":"field . as_select ( items , label = None , ** attrs ) Renders the field as a <select> element. If you use a label argument, a <label> will be added before the input, and also an id attribute to connect both (that can also be overwritten). The items argument is a list that can have two type of elements: A tuple of label, value for rendering as an <option> . A tuple of a label and another list of tuples: (label, [(label, value), ...]) . This will be rendered as an <optgroup> with the label as the title and the items in the list as <option> s inside that group. You can mix the two types of elements to have first-level <option> and <optgroup> s in the same <select> . Example: >>> items = [ ... ( \"Sidney\" , 21 ), ... ( \"Tokyo\" , 22 ), ... \"America\" , [ ... ( \"New York\" , 1 ), ... ( \"San Francisco\" , 2 ), ... ( \"Buenos Aires\" , 3 ), ... ( \"Lima\" , 4 ), ... ( \"Bogota\" , 5 ), ... ], ... \"Europe\" , [ ... ( \"Rome\" , 6 ), ... ( \"London\" , 7 ), ... ( \"Madrid\" , 8 ), ... ( \"Paris\" , 9 ), ... ( \"Berlin\" , 10 ), ... ], ... ] >>> form . city . as_select ( items , label = \"Choose a city:\" ) ''' <label for=\"city\">Choose a city:</label> <select id=\"city\" name=\"city\"> <option value=\"\">Sidney</option> <option value=\"\">Tokyo</option> <optgroup label=\"America\"> <option value=\"1\">New York</option> <option value=\"2\">San Francisco</option> <option value=\"3\">Buenos Aires</option> <option value=\"4\">Lima</option> <option value=\"5\">Bogota</option> </optgroup> <optgroup label=\"Europe\"> <option value=\"6\">Rome</option> <option value=\"7\">London</option> <option value=\"8\">Madrid</option> <option value=\"9\">Paris</option> <option value=\"10\">Berlin</option> </optgroup> </select> '''","title":"as_select( )"},{"location":"rendering/#render_optgroup","text":"field . render_optgroup ( label , items , ** attrs ) Renders an <optgroup> tag with <options> . Used by as_select() to render its groups, but you can call it yourself to build your options list by hand. The label is the title of the group and items is a list of label, value tuples for the options. Example: >>> items = [ ... ( \"Rome\" , 6 ), ... ( \"London\" , 7 ), ... ( \"Madrid\" , 8 ), ... ( \"Paris\" , 9 ), ... ( \"Berlin\" , 10 ), ... ] >>> form . city . render_optgroup ( \"Europe\" , items ) ''' <optgroup label=\"Europe\"> <option value=\"6\">Rome</option> <option value=\"7\">London</option> <option value=\"8\">Madrid</option> <option value=\"9\">Paris</option> <option value=\"10\">Berlin</option> </optgroup> '''","title":"render_optgroup( )"},{"location":"rendering/#render_option","text":"field . render_option ( label , value = None , ** attrs ) Renders an <option> element. Used by as_select() and by render_optgroup() to render its options, but you can call it yourself to build your options list by hand. If you omit the value, the label will be used as a value as well. Examples: >>> form . city . render_option ( \"Lima\" ) '<option value=\"Lima\">Lima</option>' >>> form . city . render_option ( \"Lima\" , 123 ) '<option value=\"123\">Lima</option>' >>> form . city . render_option ( \"Lima\" , \"LIM\" , data_color = \"orange\" ) '<option value=\"LIM\" data-color=\"orange\">Lima</option>'","title":"render_option( )"},{"location":"rendering/#render_error","text":"field . render_error ( tag = \"div\" , ** attrs ) If the field has an error, this methods renders a tag (a <div> by default)with an \u201cerror\u201d class and the error message. Both the tag and the class can be overwritten. If the field has no error, nothing is rendered. Examples: # If the field has a `required` error >>> form . email . render_error () '<div class=\"error\">This field is required</div>' # Custom tag and class >>> form . email . render_error ( tag = \"p\" , className = \"errorMessage\" ) '<p class=\"errorMessage\">This field is required</p>' # If the field has no error >>> form . name . render_error () ''","title":"render_error( )"},{"location":"rendering/#using-form-templates","text":"Proper Form doesn\u2019t have a default form.render() method, but you can write one yourself on each of your forms or, better yet, in a base form. For example you could have a separated template for each if your forms in a templates/forms/ folder: from flask import render_template from proper_form import Form class BaseForm ( Form ): def render ( self ): name = self . __class__ . __name__ . lower () tmpl = f \"forms/{name}.html.jinja2\" return render_template ( tmpl , form = self ) If you make all of your forms inherit from that base form, you will now be able of rendering a form just calling its .render() method. class MyForm ( BaseForm ): name = Text () ... <p>lorem ipsum</p> {{ myform.render () }} <p>lorem ipsum</p>","title":"Using form templates"},{"location":"validators/","text":"Validators # Validators are functions that take the list of values of a filed, already type casted, and check if they meet some condition, like a minimum length. Built-in validators # Proper Form includes several validators for common data needs. These are technically validator factories , because they take some arguments and return a validator as a function, tailored to your specific need. Example: class MyForm ( Form ): birthday = Date ( BeforeNow (), # You need the \"()\" even without arguments After ( datetime . date ( 1900 , 1 , 1 )), required = True ) All of these have default error messages, but you can overwrite them using a message attribute if you like. After # After ( dt , message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validate that all of the dates happens after another one. AfterNow # AfterNow ( message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validates that all of the dates happens in the future (the \u201cnow\u201d at the moment of the validation). Before # Before ( dt , message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validate that all of the dates happens before another one. BeforeNow # BeforeNow ( message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validates that all of the dates happens in the past (the \u201cnow\u201d at the moment of the validation). Confirmed # Confirmed ( message = None ) Validates that a value is identical every time has been repeated. Classic use is for password confirmation fields. Work with every type of field. InRange # InRange ( minval , maxval , message = None ) Validates that a value is of a minimum ( minval ) and a maximum ( maxval ) value. This will work with integers, floats, decimals, strings, and any data type that can be compared. LessThan # LessThan ( value , message = None ) Validates that a value is less or equal than another value (that can be an integer, a float, etc.) This will work with integers, floats, decimals, strings, and any data type that can be compared. MoreThan # MoreThan ( value , message = None ) Validates that a value is more or equal than another (that can be an integer, a float, etc.) This will work with integers, floats, decimals, strings, and any data type that can be compared. LongerThan # LongerThan ( length , message = None ) Validates the length of a value is longer or equal than a minimum length . This will work with strings, and any data type that has a \u201clength\u201d. ShorterThan # ShorterThan ( length , message = None ) Validates the length of a value is shorter or equal than a maximum length . This will work with strings, and any data type that has a \u201clength\u201d. Writing your custom validators # Validators are just functions with two properties: They must take a list of values The must return True if all values \u201care ok\u201d, or a tuple (False, \"error message\") if not. Let\u2019s write a custom validator to see it in practice: def must_yell ( values ): for value in values : if value != value . upper (): return False , \"Please YELL.\" return True And to use in a field, you pass it as an argument, like other validators: class MyForm ( Form ): message = Text ( must_yell , LongerThan ( 3 ), required = True )","title":"Validators"},{"location":"validators/#validators","text":"Validators are functions that take the list of values of a filed, already type casted, and check if they meet some condition, like a minimum length.","title":"Validators"},{"location":"validators/#built-in-validators","text":"Proper Form includes several validators for common data needs. These are technically validator factories , because they take some arguments and return a validator as a function, tailored to your specific need. Example: class MyForm ( Form ): birthday = Date ( BeforeNow (), # You need the \"()\" even without arguments After ( datetime . date ( 1900 , 1 , 1 )), required = True ) All of these have default error messages, but you can overwrite them using a message attribute if you like.","title":"Built-in validators"},{"location":"validators/#after","text":"After ( dt , message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validate that all of the dates happens after another one.","title":"After"},{"location":"validators/#afternow","text":"AfterNow ( message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validates that all of the dates happens in the future (the \u201cnow\u201d at the moment of the validation).","title":"AfterNow"},{"location":"validators/#before","text":"Before ( dt , message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validate that all of the dates happens before another one.","title":"Before"},{"location":"validators/#beforenow","text":"BeforeNow ( message = None ) Works with Date , DateTime , SplittedDateTime , and any other field that cast the values to dates. Validates that all of the dates happens in the past (the \u201cnow\u201d at the moment of the validation).","title":"BeforeNow"},{"location":"validators/#confirmed","text":"Confirmed ( message = None ) Validates that a value is identical every time has been repeated. Classic use is for password confirmation fields. Work with every type of field.","title":"Confirmed"},{"location":"validators/#inrange","text":"InRange ( minval , maxval , message = None ) Validates that a value is of a minimum ( minval ) and a maximum ( maxval ) value. This will work with integers, floats, decimals, strings, and any data type that can be compared.","title":"InRange"},{"location":"validators/#lessthan","text":"LessThan ( value , message = None ) Validates that a value is less or equal than another value (that can be an integer, a float, etc.) This will work with integers, floats, decimals, strings, and any data type that can be compared.","title":"LessThan"},{"location":"validators/#morethan","text":"MoreThan ( value , message = None ) Validates that a value is more or equal than another (that can be an integer, a float, etc.) This will work with integers, floats, decimals, strings, and any data type that can be compared.","title":"MoreThan"},{"location":"validators/#longerthan","text":"LongerThan ( length , message = None ) Validates the length of a value is longer or equal than a minimum length . This will work with strings, and any data type that has a \u201clength\u201d.","title":"LongerThan"},{"location":"validators/#shorterthan","text":"ShorterThan ( length , message = None ) Validates the length of a value is shorter or equal than a maximum length . This will work with strings, and any data type that has a \u201clength\u201d.","title":"ShorterThan"},{"location":"validators/#writing-your-custom-validators","text":"Validators are just functions with two properties: They must take a list of values The must return True if all values \u201care ok\u201d, or a tuple (False, \"error message\") if not. Let\u2019s write a custom validator to see it in practice: def must_yell ( values ): for value in values : if value != value . upper (): return False , \"Please YELL.\" return True And to use in a field, you pass it as an argument, like other validators: class MyForm ( Form ): message = Text ( must_yell , LongerThan ( 3 ), required = True )","title":"Writing your custom validators"}]}